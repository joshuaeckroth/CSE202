Each one of the problems that we have coded in the past had the
following properties: The problem was complete in the sense that it
led from certain unambiguously stated assumptions to a clearly defined
result. It was incomplete, however, in another sense: It was certain
in some cases, and very likely in others, that the problem in question
would in actual practice not occur by itself as an isolated entity,
but rather as one of the constituents of a larger and more complex
problem. It is, of course, justified and even necessary from a
didactical point of view, to treat such partial problems, problem
fragments -- especially in the earlier stages of the instruction in
the use of a code, or of coding *per se*. As the discussion advances,
however, it becomes increasingly desirable to turn one's attention
more and more from the fragments, the constituent parts, to the
whole. [...]
 
There are, in principle, two ways to effect this shift of emphasis
from the parts to the whole.
 
The first way is to utilize the experience gained in the coding of
simpler (partial) problems when one is coding more complicated (more
complete) problems, but nevertheless to code all the parts of the
complicated problem explicitly, even if equivalent simple problems
have been coded before.
 
The second way is to code simple (partial) problems first,
irrespective of the contexts (more complete problems) in which they
may occur subsequently, and then to insert these coded sequences as
wholes, when a complicated problem occurs of which they are
parts. [....]
 
We wish to develop here methods that will permit us to use the coded
sequence of a problem, when that problem occurs as a part of a more
complicated one, as a single entity, as a whole, and avoid the need
for recoding it each time when it occurs as a part in a new context,
i.e. in a new problem.
 
The importance of being able to do this is very great. It is likely to
have a decisive influence on the ease and efficiency with which a
computing automat of the type that we contemplate will be
operable. This possibility should, more than anything else, remove a
bottleneck at the preparing, setting up, and coding of problems, which
might otherwise be quite dangerous.
 
This principle must, of course, be applied with certain common sense
limitations: There will be "problems" whose coded sequences
are so simple and so short, that it is easier to recode them each time
when they occur as parts of another problem, than to substitute them
as single entities -- i.e. where the work of recoding the whole
sequence is not significantly more than the work necessitated by the
preparations and adjustments that are required when the sequence is
substituted by the preparations and adjustments that are required when
the sequence is substituted as a single entity.
 
For problems of medium or higher complexity, however, the principle
applies. It is not easy to name a precise lower limit for the
complexity, say in terms of the number of words that make up the coded
sequence of the problem in question. [...]
 
These things being understood, we may state that the possibility of
substituting the coded sequence of a simple (partial) problem as a
single entity, a whole, into that one of a more complicated (more
complete) problem, is of basic importance for the ease and efficiency
of running an automatic, high speed computing establishment in the way
that seems reasonable to us. We are therefore going to investigate the
methods by which this can be done.
 
We call the coded sequence of a problem a *routine*, and one which is
formed with the purpose of possible substitution into other routines,
a *subroutine*. [....]
 
(*Planning and Coding of Problems for an Electronic Computing
Instrument*, Herman H. Goldstine and John von Neumann, 1948.)
