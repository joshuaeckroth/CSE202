* Variables and types

It is very important when writing computer programs that one is able
to save data in temporary locations, move data in and out of these
locations and change the data over time. How we do this in C++ is with
variables.

Consider the mathematical formula <math>c = \sqrt{a^2+b^2}</math>
(Pythagoras' formula). This formula can find the length of the
hypotenuse of *any* right triangle. If we were to write a program that
implemented this formula, then we would have a program that can find
the length of the hypotenuse of any right triangle. This is clearly
useful (though perhaps not as its own program).

The reason the letters <math>a</math>, <math>b</math>, and
<math>c</math> are used in the formula is because they *stand in* for
whatever values some particular right triangle has. Our program would
ask for these values (specifically, the values for <math>a</math> and
<math>b</math> from the user (or read them from a file, or
whatever). Our program must also save these values in variables.

However, unlike mathematics, C++ variables are *typed*.  This means that
every variable in C++ is a variable of a certain type. We have the
following types available to us:

  - =int= for integers (..., -2, -1, 0, 1, 2, ...)

  - =double= for "floating point" values (i.e. decimal values like -0.5
    or <math>1.23040 * 10^{-23}</math>)

  - =string= for "strings" (i.e. text)
    
  - =bool= for true/false values

  - and some others...

Variables in C++ are typed for two reasons: (1) programs can be
executed more efficiently if the type is known beforehand and need not
be determined based on what kinds of values the user provides
(technically, this advantage is only gained because C++ is *statically*
typed, which means the types of variables never change while the
program is executing); (2) the C++ compiler is able to ensure that you
are using variables the right way by checking if you are using values
of the right type. For example, trying to save a string inside an
integer type results in an error.

** Overflow and underflow

Computers are finite machines, so they cannot store arbitrarily large
values or arbitrarily small values (i.e. teeny-tiny fractions). Most
programs do not need extremely large or small values, so very rarely
is the fact that computers are finite an issue. However, C++ types
also have their limits, and some of these limits need to be considered
when writing any program.

For any general category of types such as integers, decimal numbers,
etc. C++ has multiple specific types that you can choose from to use
in your programs. For example, =int= is not the only C++ type that
stores integer values. There is also =char=, =short=, =long=, =long long=, and
possibly more depending on the compiler. As well, =double= is not the
only type that can store decimal values. There is also =float= and =long
double=. A quick comparison of these types will help you decide which
is appropriate for each variable in your program.

** Integer types

  - =char= can store values between -127 and 128 (signed) or between 0
    and 255 (unsigned)

  - =short= can store values between -32767 and 32767 (signed) or
    between 0 and 65535 (unsigned)

  - =int= can store values between -2147483647 and 2147483647 (signed)
    or between 0 and 4294967295

  - =long= is the same as =int= (on CSE server)

  - =long long= can store values between -9223372036854775807 and
    9223372036854775807 (signed) or between 0 and 18446744073709551615
    (unsigned)

** Decimal ("floating point") types

  - =float= can store values up to <math>\pm 3.40282 * 10^{\pm 38}</math>, 6
    precision digits are kept

  - =double= can store values up to <math>\pm 1.79769 * 10^{\pm 308}</math>,
    15 precision digits are kept

  - =long double= can store values up to <math>\pm 1.7 * 10^{\pm
    4932}</math>, 18 precision digits are kept

*Note about precision in floating point types* â€” The floating point
types do not represent values precisely. It is not a good idea to do
this:

<src lang="c++">
double x;
cin >> x;
if(x == 2.5) // NOT GOOD
{
    // blah...
}
</src>

The value 2.5 cannot be represented precisely, so even if the user
inputs 2.5, it may not be stored as 2.5. Thus we cannot test if the
value is "exactly" 2.5. We must check, instead, if the value is
"close" to 2.5, using the following approach:

<src lang="c++">
double x;
cin >> x;
if(x < 2.50001 && x > 2.49999) // YES, GOOD
{
    // blah...
}
</src>

For more gory details, see:

  - [[http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm]]

  - [[http://en.wikipedia.org/wiki/Floating_point]]

** String types

A "string" is literally a collection of characters (=char=). C++ allows
us to type strings without resorting to creating lots of =char=
variables. So the string ="hello"= is literally the collection of =char=
thingies ='h'= ='e'= ='l'= ='l'= ='o'= (there is actually another special =char=
at the end that tells the computer the string is finished). The
double-quotes ="= tell C++ we are using a string; single quotes ='= tell
C++ we are referring to a =char= (which is only one thing, one symbol).

Before C++, in the C language, strings, as we use them in C++, were
not available. C++-style strings are much more convenient because you
can easily make them larger or smaller, ask how long they are, etc.

To use strings, you have to =#include <string>= Here is an example using
a =string=:

<src lang="c++">
#include <iostream>
#include <string>  // necessary to use strings
using namespace std;

int main()
{
    string myname = "Joshua Eckroth";

    cout << myname << endl;

    return 0;
}
</src>

** Commonly-used types

Although you may know your program has variables that would work just
fine as type =short= (for example), it's not always the best idea to use
=short=. The type =short= is relatively uncommon. (Think about metric
units: although you could use centiliters, it's normal to switch to
milliliters at that point.) The common types (and what you are
encouraged to use) are:

  - True/False values: =bool=

  - Integers: =int=

  - Floating point: =double=

  - Strings: =string=

Even with these large ranges of values, sometimes your variables may
suffer overflow or underflow. Overflow occurs when you try to store a
value that is too large for the type.  Underflow occurs when you try
to store a value that is too small for the type. Underflow only makes
sense with decimal types: if you try to store a very small number, say
0.0 followed by 5000 0's followed by a 1, not even a =long double= can
store that value. Overflow and underflow should be rare for the
programs we are interested in, however.

** Variable naming

Here are the rules for naming variables:

  - 1 to 255 characters

  - must begin with a letter or <code>_</code>

  - after the first letter or <code>_</code>, can contain numbers

  - uppercase and lowercase letters are considered different (e.g. =xyz=
    is not the same variable as =Xyz=)

  - "reserved" words cannot be used (e.g. "using" "namespace" "if"
    "else" etc.)

  - do not use all uppercase letters unless the variable is a
    "constant" ("constant" means its value never changes; e.g.
    <code>const double PI = 3.14159</code> is a proper use of all
    uppercase letters)

** Declaring variables

You can declare multiple variables in one line (separated by commas),
if they are all of the same type:

<src lang="c++">
double a, b, c, d, e, f, g;
int x, y, z;
</src>

You can also give them values:

<src lang="c++">
double a = 1.1, b = 2.2, c = 3.3;
int x = 1, y = 2, z = 3;
</src>

Declare and define constant values like this (using all caps for the
variable names):

<src lang="c++">
const double PI = 3.14159;
const int MULTIPLIER = 5;
</src>

Because these variables have the modifier =const=, you are not allowed
to change their values (the compiler will display an error if you
try).

* Arithmetic

Here are the normal math operators that work on integers and floating
point numbers:

  - <code>+</code> (add)

  - <code>-</code> (subtract; or a negative number, e.g. <code>int x =
    -5</code>)

  - <code>*</code> (multiply)

Here are somewhat-unique math operators that work with integers:

  - <code>/</code> (quotient: <code>13 / 5</code> is 2 because 5 goes
    into 13 two times)

  - <code>%</code> (remainder: <code>13 % 5</code> is 3 because the
    remainder of 5/13 is 2)

Note that =/= works as you would expect with floating point numbers
(e.g. <code>1.2 / 5.6</code> is about 0.214).

Precedence works the same as you would expect: <code>* / %</code>
happen before <code>+ -</code> so <code>(5 + 6 % 4 - (3 + 4) /
2)</code> equals 4 as you would expect. You can use parentheses to
clarify the math.

** Arithmetic shorthand

You can use the following shorthand for changing the values of
variables. The shorthand form is shown, then the equivalent form is
described in comments.

<src lang="c++">
double a = 0.0;
int x = 0;
x++;            // same as: x = x + 1;
x--;            // same as: x = x - 1;
x += 2;         // same as: x = x + 2;
x -= 2;         // same as: x = x - 2;
x *= 2;         // same as: x = x * 2;
x /= 2;         // same as: x = x / 2;
x %= 2;         // same as: x = x % 2;
    
a += 2.0;       // same as: a = a + 2.0;
// etc.
</src>

** Boolean operators

Variables of type =bool= have the following special operators:

<src lang="c++">
bool p = TRUE;
bool q = FALSE;
bool r;
r = !p;        // "!" means "not" or "opposite", so r == FALSE
r = p || q;    // "||" means "or", so r == TRUE
r = p && q;    // "&&" means "and", so r == FALSE
r = q || (!p)  // r == FALSE
</src>
  
Note that you cannot use "shorthand" operators with Boolean
variables. The following does *not* do what you expect: <code>r !=
p;</code>

** Mathy example

This example shows use of several mathematical functions and
operators.

<src lang="c++">
// math example
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    cout << "The reciprocal of 10 is " << 1.0/10.0 << endl;
    cout << "The square root of 10 is " << sqrt(10.0) << endl;
    cout << "e^(10.0) = " << exp(10.0) << endl;
    cout << "The reciprocal of 15 is " << 1.0/15.0 << endl;
    cout << "The square root of 15 is " << sqrt(15.0) << endl;
    cout << "e^(15.0) = " << exp(15.0) << endl;

    return 0; // exit program
}
</src>

Here is the example again, but this time with a variable =x=:

<src lang="c++">
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    double x;
       
    x = 10.0;

    cout << "The reciprocal of 10 is " << 1.0/x << endl;
    cout << "The square root of 10 is " << sqrt(x) << endl;
    cout << "e^(" << x << ") = " << exp(x) << endl;

    x = 15.0;

    cout << "The reciprocal of 15 is " << 1.0/x << endl;
    cout << "The square root of 15 is " << sqrt(x) << endl;
    cout << "e^(" << x << ") = " << exp(x) << endl;

    return 0; // exit program
}
</src>

** Conversion example

This code converts teaspoons to other units of measurement.

<src lang="c++">
#include <iostream>
using namespace std;

int main()
{
    int teaspoons;

    cout << "Please enter the number of teaspoons: ";
    cin >> teaspoons;

    int gallons = teaspoons/(3*16*2*8);
    teaspoons -= gallons*(3*16*2*8);
    int pints = teaspoons/(3*16*2);
    teaspoons -= pints*(3*16*2);
    int cups = teaspoons/(16*3);
    teaspoons -= cups*(16*3);
    int tablespoons = teaspoons/3;
    teaspoons -= tablespoons*3;

    cout << "Number of gallons: " << gallons << endl;
    cout << "Number of pints: " << pints << endl;
    cout << "Number of cups: " << cups << endl;
    cout << "Number of tablespoons: " << tablespoons << endl;
    cout << "Number of teaspoons: " << teaspoons << endl;

    return 0;
}
</src>
  
* Simple user input

You remember using =cout= to display a message. You can use =cin= to do
the opposite: get input from the user. It works like this (notice the
=>>= of =cin=, which are opposite those of =cout=):

<src lang="c++">
int x;
cout << "Give me a number: ";
cin >> x;
cout << "You gave me the number " << x << endl;
</src>

You can use =cin= for integer types, floating point types, string types,
and others. It's easiest if you ask the user to enter one value at a
time, pressing Enter between each value.

To acquire multiple values at once, just string them together with
=cin=:

<src lang="c++">
int x;
double y;
short z;
cout << "Enter three numeric values: ";
cin >> x >> y >> z;
</src>

This is equivalent to:

<src lang="c++">
int x;
double y;
short z;
cout << "Enter three numeric values: ";
cin >> x;
cin >> y;
cin >> z;
</src>

More examples:

<src lang="c++">
double a;
int x;
bool p;

cout << "Enter a decimal value: ";
cin >> a;
   
cout << "Enter an integer value: ";
cin >> x;
    
cout << "Enter a 0 for FALSE, anything else for TRUE: ";
cin >> p;
</src>

The function =cin= only collects input up to the first space or newline.

=cin= can be used to obtain multiple inputs. It knows when to delimit
(i.e. start looking for the next input) when it reaches a space or
newline (or tab).

Here's the same example as above, but using just one =cin=:

<src lang="c++">
double a;
int x;
bool p;
    
cout << "Enter a decimal, integer, and boolean value: ";
cin >> a >> x >> p;
</src>

We can get strings in the usual way:

<src lang="c++">
string word;

cout << "Enter a word: ";
cin >> word;
</src>

However, using that technique, you cannot get strings that have
spaces. To get strings that have spaces in them, we have to use this
method:

<src lang="c++">
string s;

// get a whole line of text from the user and save into the variable s
getline(cin, s);
</src>

That method gets a whole line of text, which could have spaces.

* Printing with precision

When printing "floating-point values" (such as floats, doubles, etc.)
we often need to show a specific number of digits after the decimal
point. This is known as the "precision" of the number. The actual
precision of the value will not change; we will only change the
printed precision. The following will show three digits after the
decimal point:
 
<src lang="c++">
cout.precision(3);
cout.setf(ios::fixed, ios::floatfield);
</src>

Here is a complete example:

<src lang="c++">
#include <iostream>
using namespace std;
int main()
{
    double x;
    cout << "Enter value for x: ";
    cin >> x;
    
    cout.precision(3);
    cout.setf(ios::fixed, ios::floatfield);
    
    cout << "You entered " << x << endl;
    return 0;
}
</src>

For example,

<example>
Enter value for x: 4.444444
You entered 4.444
</example>

<example>
Enter value for x: 0.0000001
You entered 0.000
</example>

<example>
Enter value for x: 123.45678
You entered 123.457
</example>
  
Notice how the last printout rounded up; the value of "x" inside the
program has not changed, however.

* Readings (not required)

  - Textbook (Etter & Ingber): pp 24-52

  - cplusplus.com: [[http://www.cplusplus.com/doc/tutorial/variables/][Variables]]; [[http://www.cplusplus.com/doc/tutorial/operators/][Operators]]; [[http://www.cplusplus.com/doc/tutorial/basic_io/][Basic input/output]]

  - learncpp.com: [[http://www.learncpp.com/cpp-tutorial/13-a-first-look-at-variables/][Variables]]; [[http://www.learncpp.com/cpp-tutorial/15-a-first-look-at-operators/][Operators]]; [[http://www.learncpp.com/cpp-tutorial/16-whitespace-and-basic-formatting/][Code indentation]]; [[http://www.learncpp.com/cpp-tutorial/21-basic-addressing-and-variable-declaration/][Creating variables]]; [[http://www.learncpp.com/cpp-tutorial/22-keywords-and-naming-identifiers/][Naming variables]]; [[http://www.learncpp.com/cpp-tutorial/23-variable-sizes-and-the-sizeof-operator/][Type sizes]]; [[http://www.learncpp.com/cpp-tutorial/24-integers/][All about integers]]; [[http://www.learncpp.com/cpp-tutorial/25-floating-point-numbers/][All about floats]]; [[http://www.learncpp.com/cpp-tutorial/26-boolean-values/][All about booleans]]; [[http://www.learncpp.com/cpp-tutorial/27-chars/][All about chars]]; [[http://www.learncpp.com/cpp-tutorial/31-precedence-and-associativity/][Operator precendence]]; [[http://www.learncpp.com/cpp-tutorial/32-arithmetic-operators/][Arithmetic operators]]; [[http://www.learncpp.com/cpp-tutorial/33-incrementdecrement-operators-and-side-effects/][Shorthand operators]]; [[http://www.learncpp.com/cpp-tutorial/35-relational-operators-comparisons/][Comparison operators]]; [[http://www.learncpp.com/cpp-tutorial/36-logical-operators/][Logical operators]]

  - Teach yourself C++ in 21 days: [[http://newdata.box.sk/bx/c/htm/ch02.htm][Parts of a program]]; [[http://newdata.box.sk/bx/c/htm/ch03.htm][Variables]]; [[http://newdata.box.sk/bx/c/htm/ch04.htm][Operators (and more)]]

  - Learning C++: [[http://www.isotton.com/devel/docs/lcpp/unpacked/node6.html][Variables ("objects")]]

  - Videos: [[http://xoax.net/comp/cpp/console/Lesson2.php][Input/output]]; [[http://xoax.net/comp/cpp/console/Lesson3.php][Variables]]; [[http://xoax.net/comp/cpp/console/Lesson4.php][Types]]; [[http://xoax.net/comp/cpp/console/Lesson24.php][More types]]; [[http://xoax.net/comp/cpp/console/Lesson5.php][Logical operators]]; [[http://xoax.net/comp/cpp/console/Lesson6.php][Comparison operators]]; [[http://xoax.net/comp/cpp/console/Lesson14.php][Shorthand operators]]; [[http://xoax.net/comp/cpp/console/Lesson21.php][Arithmetic operators]]

