* Motivation

All of our programs so far have lived entirely inside the =main()=
function. In other words, all the code was in one big pile.
Mathematics were mixed in with =cout= statements were mixed with file
operations. So far this has not been much of a problem because our
programs were small.

But we did use functions that others have written. We used the =string=
=at()= function, the =cmath= =pow()= and =sqrt()= functions, and the =open()=
and =is_open()= functions from =fstream=. Even =cout= and =cin= are functions,
though they are quite a bit more complicated and a little bit special
(actually, the stream operators =<<= and =>>= are functions too but that's
beyond the scope of this class).
 
If we did not have, say, =sqrt()=, at our disposal as functions, we
would have had to include our own code for =sqrt()= (using an
approximation method like Newton's) in our big pile of code in
=main()=. This is undesirable.

So the moral is that functions allow the programmer to *modularize* and
*isolate* code, so that in any single function, only one task is being
performed. This generally makes code more understandable.

You can think of a function as simply code that has a name. The name
of some chunk of code is what the code *does*. The =sqrt()= function
contains only enough code to find the square root of a number, for
example.
 
* Where to write your own functions
 
For now, we will write functions in the same file as =main()= so that
our programs still consist of just one file. Programs need not be just
one file, however, and in the future we will explore ways to split up
code into multiple files (by putting functions in different files).

Functions can be defined above =main()=, or they can have just a
*prototype* (or *signature*) above =main()= with the function definition
below =main()=. (Function prototypes or definitions cannot be placed
inside other functions.) Here are examples:

<src lang="c++">
#include <iostream>
using namespace std;
// this is an example of a function fully defined above main()

double timesTwo(double x)
{
    return 2*x;
}

int main()
{
    cout << timesTwo(4.5) << endl;
}
</src>

<src lang="c++">
#include <iostream>
using namespace std;

// this is an example of just a prototype above main()
// the function code itself is below main()

double timesTwo(double);

int main()
{
    cout << timesTwo(4.5) << endl;
}

double timesTwo(double x)
{
    return 2*x;
}
</src>

The importance of where the function is defined (above =main()= or not)
is that the compiler requires that either the function prototype or
the whole function itself is found *above the code that uses the
function*. If you try to use a function called =timesTwo()= but the
compiler has not seen any function by that name yet, then you get a
compiler error.
 
* Function return types and parameter types and names
 
Every function must have a return type, or =void=. The return type can
be any type we know about (e.g. =int=, =double=, =string=, =bool=, etc.). Or,
the function can be a *void function*, which means we write =void= instead
of a return type (=void= is not technically a type). The return type
goes before the function name. If the function is not a void function,
then the code inside the function must use =return= somewhere, returning
a value of the proper type. A void function does not need the =return=
command; it can include the =return= command (this causes the function
to finish) but cannot use =return= to return a value.

A function may have *arguments*. But it need not. A function that has no
arguments has empty parentheses. A function that has two =int= arguments
would have =int x, int y= in the parentheses. The =x= and =y= are usually
not typed in the function prototype (though they can be). The =x= and =y=
should be included, however, when the function is being defined.

The =x= and =y= variable names *exist only inside the function*. Assume a
function is called =add= and it takes two =int= arguments. This is what it
looks like:

<src lang="c++">
int add(int a, int b)
{
    return a+b;
}
</src>

Then when the function is called (say, from some code in =main()=), two
integer values must be provided: =add(4, 12)= (the result of that
function call is =16=, naturally). Inside the function, the =4= is
assigned to the variable name =a= and the =12= is assigned to =b=. This =a=
and =b= exist only inside the function.
 
Consider this example: 

<src lang="c++">
#include <iostream>
using namespace std;

int add(int a, int b)
{
    return a+b;
}

int main()
{
    int a = 15;
    int b = 20;
    cout << add(a, b) << endl;
}
</src>

Then the =a= and =b= inside =main()= are different variables than those
inside =add()=. Even if the code inside the function =add()= decided to
change the values of =a= and =b=, it would only change the values for the
variables known by those names inside the =add()= function, not those
known by those names inside =main()=. The function =add()= cannot access
the variables declared inside =main()=.

Since the variables inside a function are not the same as those inside
a different function, they need not have the same names:

<src lang="c++">
#include <iostream>
using namespace std;

int add(int someSillyNameX, int someSillyNameY)
{
    return (someSillyNameX + someSillyNameY);
}

int main()
{
    int a = 15;
    int b = 20;
    cout << add(a, b) << endl;
}
</src> 

Note that function names (e.g. =add=) have the same restrictions as
variable names (i.e. they cannot start with a number or special
symbol, etc.).

* Function calling & parameter passing

Imagine we made a function for the =overlap.cpp= program that checked if
the strings overlapped and a function that determined the length of
the overlap:

<src lang="c++">
#include <iostream>
#include <string>
using namespace std;

int overlapStart(string s1, string s2)
{
    int start;
    for(start = 0; start < s1.length(); start++)
    {
        if(s1.at(start) == s2.at(0))
        {
            return start;
        }
    }
    return s1.length();
}

int overlapLength(string s1, string s2, int start)
{
    int i, j;
    for(i = start, j = 0; (i < s1.length()) && (j < s2.length()); i++, j++)
    {
        if(s1.at(i) != s2.at(j))
        {
            break;
        }
    }
    return j;
}

int main()
{
    string input1, input2;
    int startOfOverlap, lengthOfOverlap;

    cout << "Enter first string: ";
    getline(cin, input1);

    cout << "Enter second string: ";
    getline(cin, input2);

    startOfOverlap = overlapStart(input1, input2);
    if(startOfOverlap == input1.length())
    {
        cout << "Second string does not overlap first string." << endl;
        return EXIT_SUCCESS;
    }

    lengthOfOverlap = overlapLength(input1, input2, startOfOverlap);

    cout << "Second string overlaps first string," << endl
         << "starting at first string position "
         << (startOfOverlap + 1) "," << endl
         << "for " << lengthOfOverlap << " characters of second string."
         << endl;

    return EXIT_SUCCESS;
}
</src>

Notice that the functions have parameters that have different names
than the calling function (in this case, =main= is the calling
function). *Parameter names for a function are unrelated to variable
names in the calling function.*

The example above uses *call-by-value*, because when the =overlapStart()=
function is called, its arguments are *just the values* of the variables
=input1= and =input2=:

<src lang="c++">
// the function receives the *values* of input1 and input2, and
// these values are actually named 's1' and 's2' in the function itself
startOfOverlap = overlapStart(input1, input2);
</src>

The same is true about =overlapLength()=: it receives only the values of
the variables given to it as arguments:

<src lang="c++">
// the function receives three values:
// a string, another string, and an integer;
// these values are named 's1', 's2', and 'start' in the function itself
lengthOfOverlap = overlapLength(input1, input2, startOfOverlap);
</src>

Functions can also use *call-by-reference*. If a function uses
call-by-reference, then it receives not just the value of an argument
but also the *memory location* of the original variable. All variables
keep track of their memory location so they know where their value is
stored in memory. When a variable is updated or assigned, the value in
the variable's memory location is changed.

When a function uses call-by-reference, it also has access to the
memory locations that the original variables (in the calling function)
used. So the function can change the values in those memory locations.

Here is an example of a function that uses call-by-reference. It's the
"increment" function, which means it takes an integer parameter and
increases that integer by one.

<src lang="c++">
#include <iostream>
using namespace std;

void increment(int &x)
{
    x++;
}

int main()
{
    int a = 5;
    increment(a);

    cout << a << endl;
    return EXIT_SUCCESS;
}
</src>

You know the =increment()= function uses call-by-reference for its
single argument because that argument has an =&amp;= in front of
it. When =main()= calls =increment()=, the variable =a= (inside =main()=) is
*passed by reference* to the function. The function does not name this
variable (and its memory location) "a" but instead names it
=x=. Otherwise, *they are the same variable*. Any changes to =x= inside the
function cause the same changes to =a= inside the calling function
(i.e. =main()=) because =x= and =a= *use the same memory location to store
their value*. We say this is a case of "call-by-reference" because it's
not the value of =a= that is being provided to the function but the
memory location to which =a= *refers*.

A function can have a mix of call-by-reference (or
"pass-by-reference") and call-by-value arguments. For example, this
function updates two variables =w0= and =w1= (which are passed by
reference, so that they can be updated) depending on the value of
another variable =y= (which is just passed by value):

<src lang="c++">
void updateXYZ(double &w0, double &w1, double y)
{
    if(y < 0.0)
    {
        w0 = w1 = 0;
    }
    else
    {
        w0 = pow(w0+w1, 2.0);
        w1 = pow(w0-w1, 2.0);
    }
}
</src>
