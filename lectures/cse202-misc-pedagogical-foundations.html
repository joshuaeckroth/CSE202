<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link rel="stylesheet" type="text/css" href="http://insearchofartifice.com/cse202/style.css" />
  <title>CSE 202 Misc: Pedagogical foundations</title>
</head>

<body>
  <h1>Pedagogical foundations</h1>

  <p>The purpose of this class is to teach basic programming concepts
  to students who have never programmed before. You will be taught not
  only the concepts of programming but how to do it in a real and very
  common language: C++. We use this language rather than a more
  "friendly" language for a variety of political, cultural, and
  practical reasons. Throughout the course I'll try to differentiate
  what is a basic programming concept and what is just a C++
  peculiarity (there are many).</p>

  <p>Teaching programming is like teaching essay-writing. The language
  of choice (be it a programming language or a "natural" language) is
  not relevant in some sense, but all the examples and practice must
  use some language or another. C++ is commonly used today so you at
  least leave this class with a practical skill as well.</p>

  <p>Essay-writing (in a language foreign to the student) shares more
  similarities with programming. Beginners often find it challenging
  not only because they may not know the language well enough to just
  "think" in that language, but also because they may not know how to
  structure their ideas and move back and forth between big ideas and
  small details. In programming, we also need to structure ideas and
  manage "levels of abstraction." The programmer must be able to
  understand a problem at an abstract level, then figure out how to
  fill in the details. C++ in particular requires the programmer to
  manage more details than some other programming languages.</p>

  <p>This is because C++ is a "low-level" language. If you are
  inclined, you can write C++ code that mucks around with the
  hardware. We're not going to do that in this class due to the
  increased complexity of the task, but you'll see throughout the
  class that some tasks you think should be simple are made much
  harder; this is because C++ has all the power necessary to code
  entire operating systems (e.g. Microsoft Windows), but our tasks
  will involve simple numerical calculations and simple interactions
  with the user through the keyboard.</p>

  <p>Why should we focus on simple tasks and not work towards a single
  huge final project? Why emphasize silly little calculations and
  question-answer sessions with the user through the keyboard? The
  answer is that learning a language or a skill "from scratch" is best
  done with lots of small examples and lots of feedback. Imagine
  teaching natural language to a child. The child cannot speak so you
  can't describe why words mean what they do. You just have to exhibit
  their meanings, by pointing to things or using the same word in the
  same context again and again. Children learn language primarily by
  repeated exposure.  (When a child is born, she does not even know
  what a word is! She does not know that the long sound Mom made is
  actually seven different words.) The sounds, the facial movements,
  and the context all play a role in helping the child figure out
  <em>what's the pattern?</em> The child utilizes a natural
  tendency of humans: when two or more things "covary" (change
  together), humans are really good at identifying that the two
  things have some kind of relationship, as if they go together.
  Thus, eventually, the child associates the sound "Cheerios" with
  the Cheerios themselves, since the two are witnessed (seen,
  heard) simultaneously again and again. The second way children
  learn language is to try it themselves. They not only try it but
  receive feedback (usually the mom just repeats the word as the
  child tries to speak it). This is "supervised learning" because
  the child receives <em>lots</em>of feedback while she's working
  through the task.</p>

  <p>On the other hand, most programming courses (and math courses for
  that matter) have fallen into the "constructivist approach" to
  teaching. This approach (which is still all the rage in academia)
  says that students learn best when they are given a hard task and
  told to solve it on their own. The students will somehow acquire the
  necessary knowledge by sheer will power. The theory is that
  knowledge you discover on your own is more memorable than what I, as
  a teacher, can give you (maybe what I say is "just facts" that are
  easily forgotten). So in the typical programming course, you are
  told "ok, here are some basic ideas, blah blah blah, now here's a
  hard problem godoit." (Many academics like this approach because it
  allows bigger classes: you can tell the students "ok go do your task
  and discuss your problems online; please answer each other's posts;
  type the answer into the website, then you will find out if you were
  right or wrong, that should be enough feedback.")</p>

  <p>But that's <em>folk pedagogy</em>. There's no research supporting
  the claim that students learn better that way. In fact,
  there <em>is</em> research supporting the opposite claim: that
  students need <em>many examples</em> and need to be
  <em>guided</em> through a task. Otherwise, how can a teacher be
  sure the student is both (1) not becoming frustrated and annoyed
  with the subject and (2) not learning a <em>bad</em> way to solve
  the problem?</p>

  <p>You will be asked to write a lot of programs. They are not all
  easy. But I hope to be able to show you many examples of similar
  programs, and not only the completed examples ("look at how
  perfectly somebody solved this problem!") but also <em>how</em> it
  was solved. It is very important that I show you how a programmer
  approaches a problem and works it out. You can know all about C++
  but not know how to solve problems in an effective manner. There is
  anecdotal evidence that without specific guidance about how to solve
  problems, students in beginning programming classes focus on
  peculiarities of the programming language and utterly fail simple
  tests. These simple tests ask the student to identify which chunk of
  code correctly performs a specific function (e.g. "which chunk of
  code correctly calculates the square root of x?"). Rather than
  seeing the chunks of code simply as "functional" units that perform
  a specific task (which is something that good problem solvers can
  do) the students only see details and process the code like a
  computer would, writing every step and mathematical result. Doing so
  involves far too much calculation, and they run out of time. The
  expert can look at a chunk of code and, without paper and pencil,
  often say "oh, this is what the code does." This is where we want to
  get in this class.</p>

  <p>Likewise, the expert knows how to solve simple problems (e.g.
  finding the square root of a number) in just a few lines of code.
  Not only that, the expert has experience solving big problems, even
  though the path to the solution is circuitous and full of
  mistakes. Novice problem solvers become expert problem solvers by
  practice and guidance, as it is with any skill.</p>

  <p>I'll summarize some of the teaching techniques I want to
  emphasize:</p>

  <ul>
    <li>I should show an example of a concept in just about every
    variation. You should see <em>lots</em> of examples. I want you
    to <em>overlearn</em> the important bits, just like how a
    basketball player practices layups again and again until it's just
    a natural movement.</li>

    <li>I should show you how problems are solved. This includes how I
    approach a problem, how I make mistakes and fix them, how I test
    ideas, etc. You should only be asked to model these techniques,
    not come up with them yourself.</li>

    <li>You should practice the techniques I show you. This is why we
    have assignments.</li>

    <li>You should practice explaining ideas and techniques and
    solutions to others. Explaining something helps you learn it
    yourself. I'll encourage this whenever possible but it will not be
    a requirement (there will be no formal "presentations").</li>

    <li>I should encourage you to solve problems in novel ways, doing
    it the way <em>you think</em> is the best. Then, we can discuss
    alternatives (possibly better ways, if they exist).</li>
  </ul>

  <p>So that covers the basics. What about programming computers?</p>

  <p>C++ is a "programming language" because it allows you to program
  a computer (of course) and it is a "language." But there are two
  types of languages: natural and formal. English, Spanish, etc. are
  natural languages. They are formal (i.e. logical) in many ways but
  it always breaks down. People use words inconsistently, omit or add
  words ("where you at?"), and use metaphor continuously ("why are you
  feeling down?"). Formal languages, on the other hand, cannot be used
  inconsistently or employ metaphor. Formal languages must be used
  according to a "syntax" or grammar. The syntax of a language is a
  set of rules that dictate how symbols (words, punctuation) can be
  used. For example, in C++, "x=5" is <em>valid</em> but "5=x" is
  <em>invalid</em>; the latter causes a "syntax error." A formal
  language is interpreted (or "understood" by the computer,
  metaphorically of course) with respect to its formal
  "semantics."&nbsp; The semantics of C++ tell us that "x=5"
  <em>causes</em> the computer to change the value of the variable
  x to the value 5. A major task of this class is to teach you the
  syntax and semantics of C++. If you are not comfortable with the
  syntax and semantics of a language, you cannot use it to solve a
  problem, just as an artist cannot paint a scene in her mind until
  she is very familiar with paint and paintbrushes.</p>

  <p>My area of study is Artificial Intelligence. Part of that field
  is natural language understanding. You may or may not be surprised
  to learn that programming a computer to understand natural language
  (whatever "understand" is supposed to mean) is extraordinarily
  difficult and maybe impossible. If it were easy, we probably would
  not have C++; we could just give the computer instructions in
  natural language. But processing natural language is very hard, and
  the main reason is words and sentences do not always (or possibly
  ever) convey a speaker's <em>intentions</em>.  The speaker's
  intentions are picked up by the listener (really,
  <em>guessed</em> by the listener) from the context of the
  situation, body language, lots of background knowledge, and
  commonsense. For example, "I'll be at Kafe Kerouac's at 7" could
  mean she'll be there at 7pm or that she won't if you believe
  she's lying.</p>

  <p>Formal languages like C++ do not allow this to happen. It's
  impossible to "lie" or express an intention other than what is
  explicitly written. And the computer never <em>guesses</em> about
  what is intended. Statements in a formal language can be thought of
  as <em>commands</em> that are always carried out just as you
  say. Even if your code is wrong (e.g. "x=5" whoops I meant x equals
  4) the computer will do as you say. <em>And it will do nothing
  else.</em> I find in classes like this one that students sometimes
  expect something to work even though their code is incorrect. The
  computer will not figure out your intentions. It is completely
  unforgiving. Like that hard math teacher. It's right, or it's
  wrong.</p>

  <p>Success in this class requires that you treat C++ and
  computers <em>as physical objects</em>, i.e. as tools. They are like
  a hammer. The hammer understands nothing. It submits to your grip
  when you pick it up, it moves through the air only as much as you
  force it to (well, gravity has some influence, too).
  <em>That</em> a hammer is used for so many practical purposes is
  besides the point, from the hammer's point of view. It simply has
  no idea. All of this is true for programming languages and
  computers as well. During this class you will become a computer
  programmer. You will have the ability to tell the computer to
  perform new and interesting tasks that you devise. The computer
  does not know what makes a problem interesting or boring, a
  program correct and efficient or buggy and slow.</p>

  <p>But neither C++ nor the hammer can enforce "good habits" or make
  you an artist. They'll both allow you to do terrible things, since
  they are just physical objects (more precisely in the case of C++,
  just let you control a physical object). But used as tools, they can
  be part of a larger process of expression.  Programmers "express
  themselves" every time they write a program.  Usually, this is not a
  very interesting process or result. But
  <em>it can be</em>. Programs are like essays or poems (after all,
  they are a written work, and more often than not they are
  intended to be read and understood by other humans as well as
  computers), and programmers are like essayists or poets. There
  are good programmers and less-good programmers. Some programmers
  do everything the easiest way (path of least resistance), while
  other programmers take great pride in their code and mull over it
  and revise it again and again. When a programmer is acting as an
  employee or as a student or professor who is trying to solve a
  problem by writing a program, there are several concurrent
  demands on the programmer:</p>

  <ol>
    <li>The program should correctly solve the problem.</li>

    <li>The program should work efficiently.</li>

    <li>The program code should be easy to understand and modify
    (because nearly all programs, at some point, must be
    changed).</li>

    <li>The program code should be written in a reasonable amount of
    time (so it probably won't be perfect).</li>
  </ol>

  <p>A programmer who is working on something just for his or her own
  enjoyment need not be concerned with any of those points. It is the
  responsibility of a teacher, however, to teach you how to meet all
  of these demands in real situations beyond the classroom.</p>

  <p>In this essay I have tried to illustrate many aspects of
  programming and learning to program. There are more subjects that I
  wish I could include here, but this essay is already far too
  long. In this class I hope to be able to address many of these
  issues and more, and ensure that you are not only being taught C++
  "in a vacuum" (if it were possible) but that you are also taught
  about problem solving and style and exposed to the greater world of
  computer programming (not just C++), computer science, formal
  languages, writing as an art, pedagogy, ....</p>
</body>
</html>
