<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link rel="stylesheet" type="text/css" href="http://insearchofartifice.com/cse202/style.css" />
  <title>CSE 202 Misc: Risk and Reassurance</title>
</head>

<body>

<h1>Risk and Reassurance</h1>

<p><em>Quoted from:</em> Sherry Turkle, <em>The Second Self: Computers
and the Human Spirit</em>, MIT Press 1984; pp 164-168.</p>

<p>At the Indianapolis racetrack, cars zoom by in the hands of master
drivers highly tuned and sensitized to the machines' response. Yet
many of these drivers end up in fatal crashes. By contrast, there is
another kind of automotive mastery, where pride comes from detailed
knowledge of cars to help insure family safety. There is mastery in
the service of the desire to operate just on the edge of disaster, and
there is mastery to feel safe. Cars can kill.  Computers don't. But
here too there are safe programmers and "racing-car" programmers,
those who pursue risk and those who avoid it.</p>

<p>Risk and reassurance can be played out in programming because the
computer presents two possibilities to the programmer: there is the
"local simplicity" of the line-by-line program and there is the global
complexity of the dynamic processes that can emerge when the program
is run.  Locally, each step in a program is easy to understand; its
effects are well defined. But the evolution of the global pattern is
not always graspable. As soon as a program reaches a certain level of
logical complexity, its behavior is no longer predictable by its
programmer in any simple sense. One is dealing with a system that
surprises. Depending on how the programmer brings local simplicity and
global complexity into focus, he or she will have a view of the
machine as completely understandable and under control or as
mysterious and unpredictable, even fraught with risk. By concentrating
on the local, the line-by-line, you feel in control. By concentrating
on the global, you see control slip away and can then feel the
exhilaration of bringing it back.</p>

<p>In Carl, the programmer who feels like "just a cog" on the job, we
have met someone who demands an understanding of the whole and a sense
of total control when he works with his computer at home. By contrast,
the "racing-car" programmers enjoy the sensation of playing with risk:
the system might "crash" or behave in unexpected ways; some new
relationship between parts of a program might trigger an unanticipated
effect in the hardware of the machine.</p>

<p>We see the spirit of risky programming in Howard, now a university
professor, who thinks of himself as a hacker. He uses the
term <em>hacker</em> to identify himself with a subculture of
programming virtuosos devoted to programming as an art in itself.</p>

<p>Howard described a fantasy in which he would walk up to any program
and "fix it, bend it to my will." As he talked, he used the kind of
hand gestures a stage magician makes toward the hat before he pulls
out the rabbit.  For Howard, what was most thrilling about the
experience of programming was "walking down a narrow line," using his
ability to make small changes to keep the whole under control while at
the same time producing dramatic effects. He was always searching for
ways to make a local fix, what he called "neat hacks"&mdash;changing
some very small thing in a program that would have a powerful "and in
the best case utterly counterintuitive" result for the system as a
whole. His was a magician’s fantasy because what he was looking for
ideally was doing something small, like touching one key or typing one
character, and having the whole system come alive.</p>

<p>Howard's fevered love of programming, which he describes as the
feeling of "walking near the edge of a cliff," contrasts with Carl's
approach, which is geared toward maintaining a safe place. Carl works
on well-defined projects he chooses himself, projects whose beginning,
middle, and end are all under his control. Carl is not interested in
mystery, in magic, in local fixes; when he programs he likes the sure
and the explainable, he likes to see the whole problem in all its
detail. Howard works on large, "almost out-of-control" programs; Carl
chooses well-defined, delimited ones. He describes his home projects
as compensation for the alienation he feels on the job and says that
he works most intensively on his home projects when he feels furthest
away from "seeing how the whole thing fits together at work." Howard
finds documentation a burdensome and unwelcome constraint; Carl enjoys
it, he likes to have a clear, unambiguous record of what he has
done. Indeed, much of his sense of power over the program derives from
his feeling of mastery over its precise specifications. Howard and
Carl may work at the same computer, but they approach it with
different aesthetics and are looking for different satisfactions.</p>

<p>This is illustrated by the computer language each prefers, the mode
each uses to communicate his ideas and intentions to the machine. The
computer can be thought of as a set of locations, each designated by a
number.  These locations are like different "addresses" within the
machine. Each address contains a sequence of elements called
bits. Each bit can be on or off. If the two states, on and off, are
given the names of 0 and 1, then the sequence of elements in any
location can be thought of as a number expressed with the digits 0 and
1.</p>

<p>Some simple operations are built into the computer. One is the
ability to transfer information stored at the various
addresses&mdash;for example, to move the contents of one address to
another or to move the sum of the contents of two addresses to a
third. Another kind of primitive operation involves taking the
contents of a given location and treating them as instructions to be
acted upon&mdash;that is, treating information within the machine as a
program. These primitive operations built into the hardware are the
machine’s language. Machine-language programming consists of getting
the computer to achieve increasingly complicated effects by stringing
together the primitive operations. When you use only these to program
you are in direct contact with the "bare machine." This does not mean
that the contact is physical. You program in machine language by
typing at a keyboard. The closeness of the contact is
symbolic&mdash;you are talking the only language that the machine can
"understand" directly. All instructions need to be designated with 0s
and 1s; locations in the machine must be referenced by number. All
other "higher-level" languages you might use will ultimately have to
be translated back into these long strings of 0s and 1s. But when you
use a high-level language you are not involved in that process of
translation. It is done for you by a translation device that takes
programs written in the high-level BASIC, or Logo, or PASCAL, or
FORTRAN and puts them into machine language.</p>

<p>Howard will program only in high-level languages. They let him play
with the computer without having to worry about the details of the
hardware. Carl knows four high-level languages, and his home system
allows him to use two of them, BASIC and PASCAL, but when he works at
home he prefers to write in "assembly language," which is a way of
programming one very small step up from machine language. In
assembly-language programming, the programmer still has to think in
terms of the machine's primitive operations, but is able to refer to
them and to locations within the machine by using easier-to-remember
names. For example, if the programmer is trying to add several
numbers, he or she may refer to the location in which the sum will
appear as "<tt>TOTAL</tt>" or "<tt>SUM</tt>" instead of referring to
it by a number, like 0000000000100011. In common parlance, when
programmers talk about "machine-language programming" they are usually
talking about assembly language. With assembly language, you are still
very close to the bare machine&mdash;only a few mnemonics away. Like a
high-level language, an assembly language needs to be translated back
to machine language. This is done using a translation program called
an "assembler." People like Carl who enjoy contact with the bare
machine and its logic often increase their contact by writing these
translation programs themselves.</p>

<p>Carl does not justify his preference for assembly language in
instrumental terms. He does not speak of how fast his
assembly-language programs can run. His reasons are subjective:
working in assembly language gives him the feeling of having direct
contact with what is "really going on" in his computer. The safety he
seeks is a symbolic safety, more like the kind that Deborah worked
toward when she constructed her "thirty-degrees world." Carl wants to
feel in close contact with machine logic; he wants the reassurance of
step-by-step mastery. Howard thinks that this kind of contact is a
"total waste of time." He doesn't even think of it as mastery of the
computer. It is simply tagging along after its machine
limitations. For Howard, programming is the enterprise of transcending
these limitations. Programming as magic means programming as
transformation.</p>

<p>In the high-level languages Howard prefers, the programmer no
longer has to think in terms of locations or of machine-level
operations, and there is no longer a transparent relationship between
the steps written by the programmer and events taking place in the
machine. The logic of high-level languages is adapted to how people
think, not how the machine "thinks." For example, in the high-level
language BASIC, an instruction might read "<tt>LET Y = SIN X</tt>." In
Logo, we saw the instructions "<tt>FORWARD 100</tt>" and "<tt>RIGHT
90</tt>" and "<tt>SETCOLOR :RED</tt>."  These instructions are far
from the 0s and 1s of machine locations. Just as an assembler stands
between an assembly-language program and the machine language, a much
more complex translator (some are called compilers, some are called
interpreters) stands between a high-level-language program and the
machine language.  When you program in Logo or BASIC, the internal
structure of the machine need never cross your mind. The compiler or
interpreter takes care of it for you. High-level languages take the
programmer away from contact with the bare machine. For Carl, this
feels like a loss; for others, like Howard, a liberation. The
differences are not simply of individual taste. Preferences in
programming language and programming style are building blocks in the
construction of computer cultures, in this case the culture of the
first-generation hobbyist and the hacker.</p>

<p>One might see the differences among computer cultures as
expressions of differences in the typical styles of their members'
personalities. For example, a young hacker might spend time with other
hackers because of shared personality traits such as a need to assert
control that is so strong, so absolute, that it can be expressed only
in relation to things. But once in their company, he or she becomes
integrated into a community that amplifies whatever shared features of
personality brought its members together. What might have begun as an
expression of individual personality develops into a social
reality.</p>


</body>
</html>
